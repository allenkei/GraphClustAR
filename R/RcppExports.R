# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Build AR(p) design matrices
#'
#' Build AR design matrices given time series data for each node.
#'
#' @param TS_by_node Numeric matrix of size N x n. Each row is the time series for a node.
#' @param lag_p Integer lag p for the AR(p) model.
#'
#' @return A list with two elements:
#' \describe{
#'   \item{X_list}{List of length N; \code{X_list[[i]]} is (n - p) x p design matrix for node i.}
#'   \item{Y_list}{List of length N; \code{Y_list[[i]]} is length (n - p) response vector for node i.}
#' }
#' @examples
#' N = 30 # nodes
#' n = 100 # time points
#' mu = 0
#' sigma = 1
#' phi = 0.8 # AR parameter
#' x_init <- rnorm(N, mean = mu, sd = sigma / sqrt(1 - phi^2))
#' TS_by_node <- matrix(0, nrow = N, ncol = n)
#' TS_by_node[, 1] <- x_init
#' eps <- matrix(rnorm(N * (n-1), 0, 1), nrow = N, ncol = n-1)
#' for (t in 2:n)  TS_by_node[,t] <- mu + phi * (TS_by_node[,t-1] - mu) + eps[,t-1] # AR(1)
#' ar_X_Y <- get_ar_X_Y(TS_by_node, lag_p=1)
#' TS_by_node[1,1:10]
#' ar_X_Y$X_list[[1]][1:6,] # design matrix with lag_p
#' ar_X_Y$Y_list[[1]][1:6]  # response at lag_p + 1
#' @export
get_ar_X_Y <- function(TS_by_node, lag_p) {
    .Call(`_GraphClustAR_get_ar_X_Y`, TS_by_node, lag_p)
}

#' Get graph information
#'
#' Convert weighted adjacency matrix to (1) edge list and (2) node degrees
#'
#' @param W Numeric matrix (N x N) weighted adjacency matrix. Must be symmetric.
#'
#' @return A list with:
#'   - edge_list: numeric matrix (i, j, w_ij)
#'   - node_degree: integer vector of node degrees
#'
#' @examples
#' # 5-node weighted, symmetric adjacency matrix
#' W <- matrix(0, nrow = 5, ncol = 5)
#' W[1, 2] <- 1.5; W[1, 4] <- 2.0; W[2, 3] <- 0.8; W[4, 5] <- 3.2
#' W <- W + t(W)
#' get_graph_info(W)
#' @export
get_graph_info <- function(W) {
    .Call(`_GraphClustAR_get_graph_info`, W)
}

#' Update phi
#'
#' ADMM update for phi using edge-wise neighbor aggregation.
#' This function will not be export in the final version.
#'
#' @param X_list List of length N; each \code{X_list[[i]]} is (n-p x p) design matrix X_i.
#' @param Y_list List of length N; each \code{Y_list[[i]]} is length n-p response vector Y_i.
#' @param phi N x d matrix of node parameters.
#' @param nu Edge-wise auxiliary variables, E x d matrix.
#' @param theta Edge-wise scaled dual variables, E x d matrix.
#' @param edge_list edge list (E by 3)
#' @param node_degree Numeric vector of length N. This is |B(i)| for each i.
#' @param gamma penalty for the augmentation term
#'
#' @return An N x d matrix with the updated phi.
#' @export
update_phi <- function(X_list, Y_list, phi, nu, theta, edge_list, node_degree, gamma) {
    .Call(`_GraphClustAR_update_phi`, X_list, Y_list, phi, nu, theta, edge_list, node_degree, gamma)
}

#' Update nu
#'
#' ADMM update for nu using group soft-thresholding.
#' This function will not be export in the final version.
#'
#' @param phi N x p matrix of node parameters (one row per node).
#' @param theta E x p matrix of scaled dual variables.
#' @param edge_list E x 3 matrix. Each row e is (i, j, w_ij)
#' @param lambda GFL penalty parameter.
#' @param gamma penalty parameter for augmentation term.
#'
#' @return Updated nu matrix of size E x p.
#' @export
update_nu <- function(phi, theta, edge_list, lambda, gamma) {
    .Call(`_GraphClustAR_update_nu`, phi, theta, edge_list, lambda, gamma)
}

#' Update theta
#'
#' ADMM update for theta
#' This function will not be export in the final version.
#'
#' @param phi N x p matrix of node parameters (one row per node).
#' @param nu E x d matrix of auxiliary variables.
#' @param theta E x p matrix of scaled dual variables.
#' @param edge_list E x 3 matrix. Each row e is (i, j, w_ij)
#'
#' @return Updated nu matrix of size E x p.
#' @export
update_theta <- function(phi, nu, theta, edge_list) {
    .Call(`_GraphClustAR_update_theta`, phi, nu, theta, edge_list)
}

#' ADMM for GraphClustAR
#'
#' ADMM for GraphClustAR (cpp version)
#' This function will not be export in the final version.
#'
#' @param X_list List of length N; each \code{X_list[[i]]} is (n-p x p) design matrix X_i.
#' @param Y_list List of length N; each \code{Y_list[[i]]} is length n-p response vector Y_i.
#' @param edge_list edge list (E by 3)
#' @param node_degree Numeric vector of length N. This is |B(i)| for each i.
#' @param lambda GFL penalty parameter.
#' @param gamma penalty for the augmentation term
#' @param lag_p Integer lag p for the AR(p) model.
#'
#' @return An N x d matrix with the updated phi.
#' @export
GraphClustAR_cpp <- function(X_list, Y_list, edge_list, node_degree, lambda, gamma, lag_p) {
    .Call(`_GraphClustAR_GraphClustAR_cpp`, X_list, Y_list, edge_list, node_degree, lambda, gamma, lag_p)
}

